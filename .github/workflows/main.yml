name: Android Super Partition Repack (Final, Reliable Method)

on:
  workflow_dispatch:
    inputs:
      stock_firmware_url:
        description: 'URL to the stock firmware (Direct HTTP, MEGA.nz, etc.). Find the real link manually.'
        required: true
        type: string
      custom_system_url:
        description: 'Custom ROM download URL (.img, .img.xz, .img.gz, .zip supported)'
        required: true
        type: string
      empty_product:
        description: 'Use empty product.img (-e flag)'
        required: false
        type: boolean
        default: false
      empty_system_ext:
        description: 'Use empty system_ext.img (-x flag)'
        required: false
        type: boolean
        default: false
      silent_mode:
        description: 'Silent mode (-s flag)'
        required: false
        type: boolean
        default: true
      writable:
        description: 'Make partitions writable (-w flag)'
        required: false
        type: boolean
        default: false
      purge_all:
        description: 'Purge repacksuper directory (-p flag)'
        required: false
        type: boolean
        # It's highly recommended to keep this true to clean up unpacked partitions
        default: true

jobs:
  repack-super:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        echo "==> Installing required OS packages..."
        sudo apt-get update
        sudo apt-get install -y \
          android-sdk-libsparse-utils \
          tar \
          xz-utils \
          liblz4-tool \
          unzip \
          gzip \
          file \
          wget \
          curl \
          megatools
        echo "✓ Dependencies installed."

    - name: Verify repacksuper.sh exists
      run: |
        if [ ! -f "./repacksuper.sh" ]; then echo "✗ Error: repacksuper.sh not found" && exit 1; fi
        chmod +x ./repacksuper.sh

    - name: Create working directory
      run: mkdir -p work

    - name: Download and Extract Stock Firmware
      run: |
        cd work
        FIRMWARE_URL="${{ github.event.inputs.stock_firmware_url }}"
        
        # Download
        if [[ $FIRMWARE_URL == *"mega.nz"* ]]; then
          megadl "$FIRMWARE_URL"
        else
          wget --content-disposition "$FIRMWARE_URL"
        fi
        
        FIRMWARE_ZIP=$(ls *.zip | head -n 1)
        if [ -z "$FIRMWARE_ZIP" ]; then echo "✗ CRITICAL ERROR: Failed to download stock firmware." && exit 1; fi
        echo "✓ Stock firmware downloaded: $FIRMWARE_ZIP"
        
        # Unzip and clean
        unzip -o "$FIRMWARE_ZIP"
        echo "==> Deleting stock firmware zip to save space..."
        rm "$FIRMWARE_ZIP"
        
        AP_FILE=$(find . -name "AP_*.tar.md5" | head -n 1)
        if [ -z "$AP_FILE" ]; then echo "✗ Error: AP file not found." && ls -lR && exit 1; fi
        echo "✓ Found AP file: $AP_FILE"
        
        # Extract super.img.lz4 and clean up the large AP file
        tar -xvf "$AP_FILE" super.img.lz4
        echo "==> Deleting AP file to save space..."
        rm "$AP_FILE"
        # Also remove other large firmware components if they exist
        rm -f BL_* CP_* HOME_CSC_* CSC_*
        
        if [ ! -f "super.img.lz4" ]; then echo "✗ Error: Could not extract super.img.lz4." && exit 1; fi
        
        # Decompress and convert to raw, cleaning up each intermediate file
        lz4 -d super.img.lz4 stock_super_sparse.img
        rm super.img.lz4
        
        simg2img stock_super_sparse.img stock_super.img
        rm stock_super_sparse.img
        
        if [ ! -f "stock_super.img" ]; then echo "✗ Error: Failed to create raw stock_super.img." && exit 1; fi
        echo "✓ stock_super.img prepared successfully! All intermediate files cleaned up."
        df -h . # Check disk space

    - name: Download and Prepare Custom system.img
      run: |
        cd work
        wget -O custom_rom_package "${{ github.event.inputs.custom_system_url }}"
        if [ ! -s "custom_rom_package" ]; then echo "✗ Error: Failed to download custom ROM." && exit 1; fi
        
        FILE_TYPE=$(file -b custom_rom_package)
        echo "File type detected: $FILE_TYPE"
        case "$FILE_TYPE" in
          *"XZ compressed data"*)      mv custom_rom_package custom_system.img.xz && unxz custom_system.img.xz ;;
          *"gzip compressed data"*)    mv custom_rom_package custom_system.img.gz && gunzip custom_system.img.gz ;;
          *"Zip archive data"*)
            unzip -o custom_rom_package system.img || unzip -o custom_rom_package system.raw.img
            # Clean up the downloaded zip immediately
            rm custom_rom_package
            SYSTEM_IMG_FILE=$(find . -maxdepth 1 -name "system.img" -o -name "system.raw.img" | head -n 1)
            if [ -z "$SYSTEM_IMG_FILE" ]; then echo "✗ Error: system.img not found in ZIP." && ls -lR && exit 1; fi
            mv "$SYSTEM_IMG_FILE" custom_system.img ;;
          *"Android sparse image"*)    mv custom_rom_package c_sparse.img && simg2img c_sparse.img custom_system.img && rm c_sparse.img ;;
          *"ext4 filesystem data"*)    mv custom_rom_package custom_system.img ;;
          *)                            rm custom_rom_package; echo "✗ Error: Unsupported file type: $FILE_TYPE" && exit 1 ;;
        esac
        # Clean up the original package if it wasn't already handled
        rm -f custom_rom_package
        if [ ! -f "custom_system.img" ]; then echo "✗ Error: custom_system.img not created." && exit 1; fi
        echo "✓ Custom system.img prepared successfully! Downloaded package cleaned up."
        df -h . # Check disk space

    - name: Prepare repacksuper.sh flags
      id: prepare_flags
      run: |
        FLAGS=""
        if [ "${{ github.event.inputs.empty_product }}" == "true" ]; then FLAGS="$FLAGS -e"; fi
        if [ "${{ github.event.inputs.empty_system_ext }}" == "true" ]; then FLAGS="$FLAGS -x"; fi
        if [ "${{ github.event.inputs.silent_mode }}" == "true" ]; then FLAGS="$FLAGS -s"; fi
        if [ "${{ github.event.inputs.writable }}" == "true" ]; then FLAGS="$FLAGS -w"; fi
        if [ "${{ github.event.inputs.purge_all }}" == "true" ]; then FLAGS="$FLAGS -p"; fi
        echo "flags=$FLAGS" >> $GITHUB_OUTPUT

    - name: Run repacksuper.sh
      run: |
        cd work
        echo "==> Running repacksuper.sh with flags: ${{ steps.prepare_flags.outputs.flags }}"
        ../repacksuper.sh ${{ steps.prepare_flags.outputs.flags }} -r "$(pwd)" stock_super.img custom_system.img repacked_super.img
        echo "==> Repacking finished. Cleaning up original super images..."
        # The script may unpack these, so we delete them after it has run
        rm stock_super.img custom_system.img
        # The -p flag in the script should handle the unpacked directory, which is a huge space saver.
        df -h . # Check disk space

    - name: Verify output and Create Tarball
      run: |
        cd work
        if [ ! -f "repacked_super.img" ]; then echo "✗ Error: repacked_super.img not found." && ls -la && exit 1; fi
        echo "✓ Repacked super.img created successfully."
        echo "==> Creating tar archive for Odin..."
        tar -cvf repacked_super.tar repacked_super.img
        echo "✓ Tar archive created."

    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: repacked-super-img
        path: |
          work/repacked_super.img
          work/repacked_super.tar
        retention-days: 7

    # Optional: If you only need the tar, you can add another cleanup step
    - name: Final Cleanup
      if: always() # Run this step even if previous steps fail, to aid in debugging
      run: |
        echo "==> Final disk space usage in working directory:"
        df -h work/
        ls -lh work/
